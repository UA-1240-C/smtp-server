<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SMTP Server: ISXThreadPool::ThreadPool&lt; FunctionType, ThreadType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SMTP Server
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ISXThreadPool</b></li><li class="navelem"><a class="el" href="classISXThreadPool_1_1ThreadPool.html">ThreadPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classISXThreadPool_1_1ThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ISXThreadPool::ThreadPool&lt; FunctionType, ThreadType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A thread pool for managing and executing tasks concurrently.  
 <a href="classISXThreadPool_1_1ThreadPool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ThreadPool_8h_source.html">ThreadPool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa78fbf1e93ac6eefb1c5b546c5d4084c" id="r_aa78fbf1e93ac6eefb1c5b546c5d4084c"><td class="memTemplParams" colspan="2">template&lt;typename InitFunction  = std::function&lt;void(std::size_t)&gt;&gt; <br />
requires std::invocable&lt;InitFunction, std::size_t&gt; &amp;&amp; std::is_same_v&lt;void, std::invoke_result_t&lt;InitFunction, std::size_t&gt;&gt;</td></tr>
<tr class="memitem:aa78fbf1e93ac6eefb1c5b546c5d4084c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classISXThreadPool_1_1ThreadPool.html#aa78fbf1e93ac6eefb1c5b546c5d4084c">ThreadPool</a> (const unsigned int &amp;number_of_threads=std::thread::hardware_concurrency(), InitFunction init=[](std::size_t) {})</td></tr>
<tr class="memdesc:aa78fbf1e93ac6eefb1c5b546c5d4084c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a thread pool with a specified number of threads.  <br /></td></tr>
<tr class="separator:aa78fbf1e93ac6eefb1c5b546c5d4084c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce974069e2437ae07ece9696aceeaee" id="r_a4ce974069e2437ae07ece9696aceeaee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classISXThreadPool_1_1ThreadPool.html#a4ce974069e2437ae07ece9696aceeaee">~ThreadPool</a> ()</td></tr>
<tr class="memdesc:a4ce974069e2437ae07ece9696aceeaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the thread pool.  <br /></td></tr>
<tr class="separator:a4ce974069e2437ae07ece9696aceeaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3a237aac309b71be51c3ef718ad758" id="r_a5d3a237aac309b71be51c3ef718ad758"><td class="memItemLeft" align="right" valign="top"><a id="a5d3a237aac309b71be51c3ef718ad758" name="a5d3a237aac309b71be51c3ef718ad758"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadPool</b> (const <a class="el" href="classISXThreadPool_1_1ThreadPool.html">ThreadPool</a> &amp;)=delete</td></tr>
<tr class="memdesc:a5d3a237aac309b71be51c3ef718ad758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread pool is non-copyable. <br /></td></tr>
<tr class="separator:a5d3a237aac309b71be51c3ef718ad758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79a8347ae068db6a6d90a72caec73bc" id="r_ab79a8347ae068db6a6d90a72caec73bc"><td class="memItemLeft" align="right" valign="top"><a id="ab79a8347ae068db6a6d90a72caec73bc" name="ab79a8347ae068db6a6d90a72caec73bc"></a>
<a class="el" href="classISXThreadPool_1_1ThreadPool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classISXThreadPool_1_1ThreadPool.html">ThreadPool</a> &amp;)=delete</td></tr>
<tr class="separator:ab79a8347ae068db6a6d90a72caec73bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8b8533020b8301e038a467540f0bb6" id="r_a6f8b8533020b8301e038a467540f0bb6"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename... Args, typename ReturnType  = std::invoke_result_t&lt;Function &amp;&amp;, Args &amp;&amp;...&gt;&gt; <br />
requires std::invocable&lt;Function, Args...&gt;</td></tr>
<tr class="memitem:a6f8b8533020b8301e038a467540f0bb6"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; ReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classISXThreadPool_1_1ThreadPool.html#a6f8b8533020b8301e038a467540f0bb6">Enqueue</a> (Function f, Args... args)</td></tr>
<tr class="memdesc:a6f8b8533020b8301e038a467540f0bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a task into the thread pool that returns a result.  <br /></td></tr>
<tr class="separator:a6f8b8533020b8301e038a467540f0bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5257263d533c004944f15351bba6082d" id="r_a5257263d533c004944f15351bba6082d"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename... Args&gt; <br />
requires std::invocable&lt;Function, Args...&gt;</td></tr>
<tr class="memitem:a5257263d533c004944f15351bba6082d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classISXThreadPool_1_1ThreadPool.html#a5257263d533c004944f15351bba6082d">EnqueueDetach</a> (Function &amp;&amp;func, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5257263d533c004944f15351bba6082d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a task to be executed in the thread pool. Any return value of the function will be ignored.  <br /></td></tr>
<tr class="separator:a5257263d533c004944f15351bba6082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ab83166ad1e9ef728c99bb4e73c34a" id="r_a56ab83166ad1e9ef728c99bb4e73c34a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classISXThreadPool_1_1ThreadPool.html#a56ab83166ad1e9ef728c99bb4e73c34a">Size</a> () const</td></tr>
<tr class="memdesc:a56ab83166ad1e9ef728c99bb4e73c34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of threads in the pool.  <br /></td></tr>
<tr class="separator:a56ab83166ad1e9ef728c99bb4e73c34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d27ee35353e663c99f64101fa3be4b6" id="r_a4d27ee35353e663c99f64101fa3be4b6"><td class="memItemLeft" align="right" valign="top"><a id="a4d27ee35353e663c99f64101fa3be4b6" name="a4d27ee35353e663c99f64101fa3be4b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WaitForTasks</b> () const</td></tr>
<tr class="memdesc:a4d27ee35353e663c99f64101fa3be4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all tasks to finish. <br /></td></tr>
<tr class="separator:a4d27ee35353e663c99f64101fa3be4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename FunctionType = std::function&lt;void()&gt;, typename ThreadType = std::jthread&gt;<br />
requires std::invocable&lt;FunctionType&gt; &amp;&amp; std::is_same_v&lt;void, std::invoke_result_t&lt;FunctionType&gt;&gt;<br />
class ISXThreadPool::ThreadPool&lt; FunctionType, ThreadType &gt;</div><p>A thread pool for managing and executing tasks concurrently. </p>
<p>This class provides a thread pool that can manage a collection of threads, execute tasks concurrently, and synchronize the completion of tasks. The thread pool allows tasks to be enqueued for execution, either with or without return values, and supports thread initialization functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctionType</td><td>The type of function to be executed by the threads in the pool. Defaults to std::function&lt;void()&gt;. </td></tr>
    <tr><td class="paramname">ThreadType</td><td>The type of thread to be used in the pool. Defaults to std::jthread. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa78fbf1e93ac6eefb1c5b546c5d4084c" name="aa78fbf1e93ac6eefb1c5b546c5d4084c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78fbf1e93ac6eefb1c5b546c5d4084c">&#9670;&#160;</a></span>ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionType  = std::function&lt;void()&gt;, typename ThreadType  = std::jthread&gt; </div>
<div class="memtemplate">
template&lt;typename InitFunction  = std::function&lt;void(std::size_t)&gt;&gt; <br />
requires std::invocable&lt;InitFunction, std::size_t&gt; &amp;&amp; std::is_same_v&lt;void, std::invoke_result_t&lt;InitFunction, std::size_t&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classISXThreadPool_1_1ThreadPool.html">ISXThreadPool::ThreadPool</a>&lt; FunctionType, ThreadType &gt;::ThreadPool </td>
          <td>(</td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>number_of_threads</em> = <code>std::thread::hardware_concurrency()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InitFunction&#160;</td>
          <td class="paramname"><em>init</em> = <code>[](std::size_t)&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a thread pool with a specified number of threads. </p>
<p>The constructor initializes the thread pool with the given number of threads and an optional initialization function that is called for each thread. In the body of the constructor each thread is being initialized with specific task.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InitFunction</td><td>The type of the initialization function. Defaults to std::function&lt;void(std::size_t)&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_threads</td><td>The number of threads to create in the pool. Defaults to the hardware concurrency. </td></tr>
    <tr><td class="paramname">init</td><td>The initialization function to call for each thread. Defaults to an empty function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ce974069e2437ae07ece9696aceeaee" name="a4ce974069e2437ae07ece9696aceeaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce974069e2437ae07ece9696aceeaee">&#9670;&#160;</a></span>~ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionType  = std::function&lt;void()&gt;, typename ThreadType  = std::jthread&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classISXThreadPool_1_1ThreadPool.html">ISXThreadPool::ThreadPool</a>&lt; FunctionType, ThreadType &gt;::~<a class="el" href="classISXThreadPool_1_1ThreadPool.html">ThreadPool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the thread pool. </p>
<p>The destructor waits for all tasks to complete and stops all threads in the pool. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6f8b8533020b8301e038a467540f0bb6" name="a6f8b8533020b8301e038a467540f0bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8b8533020b8301e038a467540f0bb6">&#9670;&#160;</a></span>Enqueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionType  = std::function&lt;void()&gt;, typename ThreadType  = std::jthread&gt; </div>
<div class="memtemplate">
template&lt;typename Function , typename... Args, typename ReturnType  = std::invoke_result_t&lt;Function &amp;&amp;, Args &amp;&amp;...&gt;&gt; <br />
requires std::invocable&lt;Function, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; ReturnType &gt; <a class="el" href="classISXThreadPool_1_1ThreadPool.html">ISXThreadPool::ThreadPool</a>&lt; FunctionType, ThreadType &gt;::Enqueue </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a task into the thread pool that returns a result. </p>
<p>Note that task execution begins once the task is enqueued. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>An invokable type. </td></tr>
    <tr><td class="paramname">Args</td><td>Argument parameter pack </td></tr>
    <tr><td class="paramname">ReturnType</td><td>The return type of the Function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The callable function </td></tr>
    <tr><td class="paramname">args</td><td>The parameters that will be passed (copied) to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::future&lt;ReturnType&gt; that can be used to retrieve the returned value. </dd></dl>

</div>
</div>
<a id="a5257263d533c004944f15351bba6082d" name="a5257263d533c004944f15351bba6082d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5257263d533c004944f15351bba6082d">&#9670;&#160;</a></span>EnqueueDetach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionType  = std::function&lt;void()&gt;, typename ThreadType  = std::jthread&gt; </div>
<div class="memtemplate">
template&lt;typename Function , typename... Args&gt; <br />
requires std::invocable&lt;Function, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classISXThreadPool_1_1ThreadPool.html">ISXThreadPool::ThreadPool</a>&lt; FunctionType, ThreadType &gt;::EnqueueDetach </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a task to be executed in the thread pool. Any return value of the function will be ignored. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>An invokable type. </td></tr>
    <tr><td class="paramname">Args</td><td>Argument parameter pack for Function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The callable to be executed </td></tr>
    <tr><td class="paramname">args</td><td>Arguments that will be passed to the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56ab83166ad1e9ef728c99bb4e73c34a" name="a56ab83166ad1e9ef728c99bb4e73c34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ab83166ad1e9ef728c99bb4e73c34a">&#9670;&#160;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionType  = std::function&lt;void()&gt;, typename ThreadType  = std::jthread&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classISXThreadPool_1_1ThreadPool.html">ISXThreadPool::ThreadPool</a>&lt; FunctionType, ThreadType &gt;::Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of threads in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>std::size_t The number of threads in the pool. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/Utils/include/<a class="el" href="ThreadPool_8h_source.html">ThreadPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
